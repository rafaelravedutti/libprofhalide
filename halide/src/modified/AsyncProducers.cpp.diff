diff --git a/src/AsyncProducers.cpp b/src/AsyncProducers.cpp
index 8d07c970d..f851d82ac 100644
--- a/src/AsyncProducers.cpp
+++ b/src/AsyncProducers.cpp
@@ -110,13 +110,13 @@ class GenerateProducerBody : public NoOpCollapsingMutator {
                 body = Block::make(body, Evaluate::make(release));
                 sema.pop_back();
             }
-            return ProducerConsumer::make_produce(op->name, body);
+            return ProducerConsumer::make_produce(op->name, body, op->must_profile);
         } else {
             Stmt body = mutate(op->body);
             if (is_no_op(body) || op->is_producer) {
                 return body;
             } else {
-                return ProducerConsumer::make(op->name, op->is_producer, body);
+                return ProducerConsumer::make(op->name, op->is_producer, body, op->must_profile);
             }
         }
     }
@@ -412,38 +412,38 @@ class InitializeSemaphores : public IRMutator2 {
 class TightenProducerConsumerNodes : public IRMutator2 {
     using IRMutator2::visit;
 
-    Stmt make_producer_consumer(string name, bool is_producer, Stmt body, const Scope<int> &scope) {
+    Stmt make_producer_consumer(string name, bool is_producer, Stmt body, const Scope<int> &scope, bool must_profile = false) {
         if (const LetStmt *let = body.as<LetStmt>()) {
             if (expr_uses_vars(let->value, scope)) {
-                return ProducerConsumer::make(name, is_producer, body);
+                return ProducerConsumer::make(name, is_producer, body, must_profile);
             } else {
-                return LetStmt::make(let->name, let->value, make_producer_consumer(name, is_producer, let->body, scope));
+                return LetStmt::make(let->name, let->value, make_producer_consumer(name, is_producer, let->body, scope, must_profile));
             }
         } else if (const Block *block = body.as<Block>()) {
             // Check which sides it's used on
             bool first = stmt_uses_vars(block->first, scope);
             bool rest = stmt_uses_vars(block->rest, scope);
             if (is_producer) {
-                return ProducerConsumer::make(name, is_producer, body);
+                return ProducerConsumer::make(name, is_producer, body, must_profile);
             } else if (first && rest) {
-                return Block::make(make_producer_consumer(name, is_producer, block->first, scope),
-                                   make_producer_consumer(name, is_producer, block->rest, scope));
+                return Block::make(make_producer_consumer(name, is_producer, block->first, scope, must_profile),
+                                   make_producer_consumer(name, is_producer, block->rest, scope, must_profile));
             } else if (first) {
-                return Block::make(make_producer_consumer(name, is_producer, block->first, scope), block->rest);
+                return Block::make(make_producer_consumer(name, is_producer, block->first, scope, must_profile), block->rest);
             } else if (rest) {
-                return Block::make(block->first, make_producer_consumer(name, is_producer, block->rest, scope));
+                return Block::make(block->first, make_producer_consumer(name, is_producer, block->rest, scope, must_profile));
             } else {
                 // Used on neither side?!
                 return body;
             }
         } else if (const ProducerConsumer *pc = body.as<ProducerConsumer>()) {
-            return ProducerConsumer::make(pc->name, pc->is_producer, make_producer_consumer(name, is_producer, pc->body, scope));
+            return ProducerConsumer::make(pc->name, pc->is_producer, make_producer_consumer(name, is_producer, pc->body, scope, must_profile), must_profile);
         } else if (const Realize *r = body.as<Realize>()) {
             return Realize::make(r->name, r->types, r->memory_type,
                                  r->bounds, r->condition,
-                                 make_producer_consumer(name, is_producer, r->body, scope));
+                                 make_producer_consumer(name, is_producer, r->body, scope, must_profile));
         } else {
-            return ProducerConsumer::make(name, is_producer, body);
+            return ProducerConsumer::make(name, is_producer, body, must_profile);
         }
     }
 
@@ -459,7 +459,7 @@ class TightenProducerConsumerNodes : public IRMutator2 {
                 scope.push(op->name + "." + std::to_string(i) + ".buffer", 0);
             }
         }
-        return make_producer_consumer(op->name, op->is_producer, body, scope);
+        return make_producer_consumer(op->name, op->is_producer, body, scope, op->must_profile);
     }
 
     const map<string, Function> &env;
@@ -515,9 +515,9 @@ class ExpandAcquireNodes : public IRMutator2 {
         Stmt body = mutate(op->body);
         if (const Acquire *a = body.as<Acquire>()) {
             return Acquire::make(a->semaphore, a->count,
-                                 mutate(ProducerConsumer::make(op->name, op->is_producer, a->body)));
+                                 mutate(ProducerConsumer::make(op->name, op->is_producer, a->body, op->must_profile)));
         } else {
-            return ProducerConsumer::make(op->name, op->is_producer, body);
+            return ProducerConsumer::make(op->name, op->is_producer, body, op->must_profile);
         }
     }
 };
